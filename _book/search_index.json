[["index.html", "Applying Network Analysis to Humanities About this Book", " Applying Network Analysis to Humanities Yann Ryan, Iiro Tihonen 2022-09-27 About this Book This book is a collection of notebooks intended to supplement the “Applying Network Analysis to Humanities’ course at the University of Helsinki, beginning November 2022. Course page on Studies Service Browse the chapters using the navigation bar on the left. If you’re doing the course, you’ll need to open the interactive notebook versions of these chapters, which contain required weekly exercises. See the chapter 2 for more details on this, and how to submit. "],["week-1-class-1-course-introduction.html", "Week 1, class 1: Course Introduction Introduction How to use this book and follow the course. What do we mean by a ‘network’? Graph Theory Why use networks in humanities? Network Basics Bipartite networks From Bridges to Social Networks… The ‘New’ Science of Networks Conclusion EXERCISE: What is R Markdown? More resources", " Week 1, class 1: Course Introduction Slides for this week Introduction This course will teach you how to use networks to ask (and hopefully answer) questions relating to humanities. More specifically than this, you’ll use the science of networks to model entities, and the relationships between them. To do this, you’ll use your knowledge of a subject to build a data model: a way to conceptualise the way your data all fits together, in a way that allows you to extract network data from it. How to use this book and follow the course. Each week, you will need to complete a short assignment. The final section of this chapter, EXERCISE: What is R Markdown?, contains this assignment. Soon, you’ll log into the CSC notebooks server, and open a source copy of this section, which is interactive, allowing you to edit and run code. After each week, you’ll open the interactive notebook, complete the assignment, and upload the file. As we haven’t introduced R yet, for this week, your only task is to make a copy of the exercise in your personal folder, ‘knit’ it, and send the resulting file to the course leader. In the following weeks, this is the method you’ll need to use to submit the assignments, so this is an opportunity to familiarise yourself with it, and to iron out any problems. What do we mean by a ‘network’? The word ‘network’ is ubiquitous in our daily lives. The Oxford English Dictionary tells us the term itself originally was first defined as Work (esp. manufactured work) in which threads, wires, etc., are crossed or interlaced in the fashion of a net. (think patch work), but now we commonly use it for any complex system of interrelated things: we all use social networking, and the telephone, railway, and road networks; an area of a city might be described as having networks of alleyways, or a historian might write about a network of trading posts. These are all in some way metaphorical. The networks we’ll learn about and use on this course have a more specific definition. In mathematics, a network is an object made up of things and connections. To use the standard language, the things are called nodes (or sometimes vertices), and the connections called edges. These things (and connections) could be almost anything. Some typical examples include: Nodes are people, and the edges their friendships or followers, as in a typical social network. The nodes are books and authors, and the connection is ‘written by’. Nodes are web pages on the internet In this final example, what might the connections be? The connections between web pages are generally the hyperlinks: the system of links known as the World Wide Web. Graph Theory Representing data in this way allows us to use the mathematics of graph theory to find out things about it. The origins of this date back to the 18th century, and the mathematician Leonard Euler. The city of Königsberg (now Kaliningrad) was built on a river with two islands and a system (a network, perhaps?) of seven bridges connecting them. The inhabitants of the city had long wondered if there it was possible to devise a route which would cross each bridge exactly once. Euler solved this problem by abstracting the bridge system into what we now call a graph: a structure with nodes and edges. He used this approach to prove that the path was only possible if the graph had exactly zero or two nodes with a degree (a count of the total connections) with an odd number. This process: abstracting a system to its connections, and devising mathematical rules to understand it, forms the basis of modern graph theory. Graph theory has methods to perform all sorts of calculations on the network: both on the individual nodes (for example to find the most important nodes by various measurements), and on the network as a whole. Rather than think about each individual relationship separately, a network model means that we can understand some more about how each part is interrelated, how the structure itself is important, and how one node might affect another in complex ways. Why use networks in humanities? Network analysis has become one of the most popular (and perhaps one of the most overused) techniques in the digital humanities toolbox. Over this course, we’ll ask you to think critically about the methods you use and when they might not always be the best way to think about your data. At the same time, network analysis does have plenty to offer the digital humanist: Humanities data is messy and complex, and network analysis deals well with complexity. The ubiquitous ‘hairball graph’, for example, might in some cases be the best way to get an overview of the structure of a large set of humanities data. Human relationships are naturally interrelated. The reason two individuals might exchange correspondence is not generally random, but strongly dependent on a wider network, for example whether they have friends in common. Networks can help to untangle these dependencies. Network analysis doesn’t always provide the answers, but it can be a way to filter down to particularly important individuals or relationships in a dataset, worthy of a further look with your humanities hat on. There are lots of other ways the tools of networks are useful, where understanding the network itself is not the end goal. For example, knowledge graphs, or certain techniques for information retrieval. Network Basics As already mentioned, a network is a graph consisting of nodes and edges (connections). These are often represented visually as points (the nodes) and lines (the edges), like this: These connections can often have a weight attached, for example the number of letters exchanged between two people, or the number of times two actors appear in a scene in a movie or play together. These weights can be used in the calculations. Edges can also have directions, meaning that the incoming and outgoing links are counted separately: for example we might count incoming and outgoing letters separately. What might this letter count tell us about a relationship in a network? What potential danger is there is reading something from this? These directed edges can also have separate weights attached to them: Bipartite networks In the above examples, the nodes and connections has been obvious. Later in the course, we’ll introduce bipartite networks. These networks are very common, particularly in humanities research. A bipartite network is one where the nodes are of different types, for example we might have a bipartite network of actors and movies, where the edges mean a particular actor has acted in that movie. An actor can be connected to one (or many) movie, but the two types of nodes cannot be connected to each other (a movie can’t really act in another movie). These types of networks require some thought before the regular network metrics are applied to them. From Bridges to Social Networks… In the 20th century, this same approach began to be used by the new discipline of sociology, applied to friendship networks. The gave birth to the field of ‘social network analysis’, which over the past half a century or so has developed a whole range of theories governing the ways networks of people are formed, and what implications this has for the way they act. Human nodes naturally behave quite differently to an island, after all. In what specific way might the connection between two people have different attributes to a connection between two islands? The Strength of Weak Ties We won’t deal with all of these theories here, but will mention a few key ones which are good demonstrations of the way in which graph theory has been applied to social networks, and the kinds of things it has determined.. One of the pioneers of social network analysis was Mark Granovetter. In a 1973 paper, Mark Granovetter argued that the most important ties in a network are often those which connect two separate social groups together. These ties, according to Granovatter, occupy a ‘brokerage’ position, and can be key in certain situations. For example, paradoxically, job seekers are more likely to find the most useful leads through their distant acquaintances rather than their close friends… Why might this be the case? It’s because, wrote Granovetter, these distant acquaintances are more likely to be able to provide ‘new’ information on opportunities: a close friend, on the other hand, will probably have access to the same information as you. This ‘brokerage’ position can be deduced mathematically using a metric known as betweenness centrality (we’ll come back to that in a later class). It’s a Small World Another important early finding of social network analysis came from a series of experiments by the social psychologist Stanley Milgram. In 1967 Milgram devised an experiment where a series of postcards were mailed out to random people in US cities. These postcards contained basic information about a ‘target’ person in another, geographically-distant, city. The participants were asked to send the postcard to that person if they knew them, and if not, send it to the contact they thought might be most likely to know that person. The details of each person were recorded on the postcard at every step. What problems can you imagine with this experiment? It’s worth considering how the experiment may be biased. Are all groups of people equally likely to answer (or have the time and money to carry out) a request from a random postcard? How might this have distorted the findings? When (or if) a postcard made it to the target person, Milgram could see how many ‘hops’ it had taken in order to get there. The average number of hops was between five and a half and six: this information was later used to claim that everyone in the US was connected by ‘six degrees of separation’. In network terms, this is known as the ‘average path length’ of the network. This fact is known as the ‘small world’ effect. It is also connected to the ‘strength of weak ties’ theory by Granovetter. This surprisingly-small number is possible because of the structure of social networks: if you want to reach someone in a distant city, are you more likely to have success if you send it to a close neighbour, or a distant acquaintance who lives there? The ‘New’ Science of Networks The most common use of networks in academic research much of the 20th century was looking at these small, sociological networks of relationships between people. This changed in the late 1990s, when a group of scientists began to use network research to understand the structures governing many kinds of complex systems, initially using the approach to map out the structure of the World Wide Web. This research showed that many of these complex networks had a similar structure: a small number of nodes with a very large number of connections, known as hubs, and a large number of nodes with very few connections. In fact, they argued, the structure followed what is known as a power-law: essentially many nodes have a very small number of connections, an exponentially smaller number of nodes have an exponentially larger number of connections, and so forth until a tiny of number of nodes have very many connections. These researchers, notably Albert Barabasi, argued that this process was guided by preferential attachment, meaning that these networks were created because nodes were much more likely to attach themselves to nodes which already had many connections. Perhaps most importantly, they empirically showed that this particular structure could be found across a range of networks, from computers, to people, to biological networks or the structure of neurons in the brain. Conclusion This outline has hopefully got you thinking about this network approach to data. A word of warning: almost everything can be represented as some kind of network. However, many of the findings from them require some careful thought: do they tell us something interesting, such as why a group of contacts formed in a particular formed in this way, or do they just reflect the data that we have collected or have available? What does a complex ‘hairball’ network diagram really tell us? Between now and the next class, try to consider the ways some of the data you have used in your studies might be thought of as a network, and what benefits (and pitfalls) that approach might bring. EXERCISE: What is R Markdown? First things first: what is this R markdown document, and how do you use it? An R Markdown file is a format which can be used to create code notebooks: interactive documents containing text and code. Essentially it is a plain text file with the extension .Rmd. It has three types of content: A YAML header (the text at the top in between two sets of —) R code ‘chunks’ (these are the grey boxes which start and end with ```{r}) Plain text. Text outside the code is treated as ordinary text. The RStudio Interface for R Markdown When you open a file with extension .Rmd in R Studio (as you will shortly), it automatically detects it as an R Markdown file, and becomes an editor. This is what it should look like: Two sections are highlighted in the image above, which are the most important parts of the editor you’ll need to be aware of. The first bar contains a few important buttons. The first, a drop-down which currently has ‘Preview’ selected, gives you options to ‘knit’ your document (we’ll return to that later). The second, a small green ‘c’ with a plus sign beside it, allows you to create a new code chunk. The third, another drop-down which currently displays ‘Run’, gives you options to run (or execute) one or more of your code chunks. The second highlighted box, just underneath, allows you to switch between ‘Source’ and ‘Visual’. The default, ‘Source’, shows the original markdown file. ‘Visual’ changes to a visual editor, which allows you to edit the document with a user interface similar to a word processor. This might be useful if you use markdown to write an extended document, for the final project for this course, for example. Now we return to the three components of the markdown document (the header, the code chunks, and the plain text). YAML Header The YAML header is a special language which configures the R markdown. You won’t need to change this much, but you can specify a title and change some settings relating to how the document is knit. Code Chunks The code chunks are, naturally, a very important element in the document. When you create a code chunk, using the menu item mentioned above, or by typing X and then ending with another X , a grey box will appear. Any entered in this box will be interpreted as R code. In the top-right corner are three icons. You can run everything in the chunk by pressing the small green triangle, and the results will display directly below the chunk. Doing it for chunk below this text (if you’re looking at the interactive version in CSC notebooks) will run the code 1 + 1, and print the answer directly below. Clicking on the ‘options’ cog, will display some settings you can change: in some instances when making an R markdown document, you might want to hide the code and just display the output, for example. You can use the options here to do that for an individual chunk. 1 + 1 ## [1] 2 Text Editor The third key component is the text editor. The point of an R Markdown document is to combine text (for example, explanations of the method you’ve used, or even an entire article where the chunks generate the figures) and code. The text can be formatted using a simple syntax called Markdown. Markdown is a widely-used web standard which allows you to specify thinks like headings, bullet points, italics and bold text. You can learn the basic syntax here, but here are the most important ones: For the moment, that’s really all you need to know about editing R Markdown itself. We’ll expand on this over the next few weeks, as you become more familiar with R. You can also use the visual editor to format your text. Saving and Knitting a copy The second part of this exercise tasks you with logging into the CSC notebooks workspace, loading the R-Studio application, saving and ‘knitting’ the R markdown file to your personal work area. Log into the CSC notebooks workspace In order to open and run the code for this course, we’ll use the CSC notebooks server. This allows you to log into a pre-made workspace containing all the relevant notebooks for the course. First, login to CSC notebooks. Open https://notebooks-beta.rahtiapp.fi/ and log in, using your CSC account. You’ll see a home screen like this: Next, join the workspace. Click the ‘join workspace’ button at the top-right of the window, and copy and paste in the join code you have been sent by email. Once you’ve done this, click on ‘My Workspaces’ using the left-side menu. You should now see a workspace called ‘Network Analysis for Humanities’, and within this, an RStudio application called ‘Network Analysis Course’. Click the big ‘power’ button on the right to start the session. The application should now open in a new tab. RStudio Once the session has loaded, the browser window will display an instance of R-Studio. R Studio is an IDE—an interface for the programming language R. Again, don’t worry too much about the details of this now - you’ll learn how to use it properly over the next few weeks. For now, just concentrate on opening, saving, and knitting the R document. First, you need to find and open the markdown document itself. The bottom-right window pane is displaying the file browser - this is how you can open files in R. Click into the applying-network-analysis-to-humanities folder, and then within that open the notebooks/ folder. Open the file 1-1-introduction.Rmd by clicking on it. It will open in the top left pane, with the editor options we walked through above. The first thing you need to do is move the file to your own workspace. This is a folder called my-work only you can write to, which is persistent for the duration of the course (it will be deleted after that, so make sure you make a copy of anything you want to save). Using the file pane, select the 1-1-introduction.Rmd file by clicking the text box to the left. Next, click the ‘more’ cog just above, and the ‘Copy to’ option. In the pop-up box, navigate to your own folder (click on the Home icon, then you should see it). Add your initials to the filename and click ‘Choose’ to save it. Once you’ve done this, you can close this copy of the file, navigate to your folder using the files pane, and open the new copy. Knit the file. The final task is to knit the file. To ‘knit’ a file means that it is turned into an HTML webpage, which will include the text, the code chunks (unless hidden), and all the results of the executed code. Click on the drop-down which currently displays ‘Preview’, above the file you’ve just opened. Select ‘Knit to HTML’. This will run the code, and generate an HTML document in the same folder. Download and send it to the course leaders. Download the newly-generated HTML file to your computer by selecting it with the checkbox, then the ‘More’ cog and ‘Export’. The file will be downloaded to your local Downloads folder. More resources There are loads of resources out there to learn more about RMarkdown: https://bookdown.org/yihui/rmarkdown/ https://rmarkdown.rstudio.com/articles.html "],["week-1-class-2-introduction-to-r-and-the-tidyverse.html", "Week 1, Class 2: Introduction to R and the Tidyverse Exercises R and R-Studio Using R Tidyverse Reading in external data EXERCISES - R Basics and Tidyverse", " Week 1, Class 2: Introduction to R and the Tidyverse Exercises Note: the final section (EXERCISES - R Basics and Tidyverse) of this chapter has a number of exercises. These are stored as a separate notebook in the CSC notebook workspace, with the name 1-2-intro-to-r.Rmd. You’ll need to move a copy to your ‘my-work’ folder in your CSC notebook Workspace, complete the exercises, and knit them, using the method we learned in the previous class. Once this is done, send a copy of the HTML file to the course leaders. R and R-Studio Throughout this course, we’ll mostly work on networks and data using the programming lanugage R and a popular extension known as ‘the tidyverse’. This will be done using R-Studio, an interface designed to make R easier to work with, known as an IDE. For this course, the data, files, and interface are all already set up for you in the CSC Notebooks workspace. In most cases, you will want to install R and R-Studio on your local machine. See here for instructions on how to do this. Logging into CSC notebooks and opening a notebook. The first thing you should do is log in to CSC Notebooks, and start the RStudio application, [as explained in the previous chapter]. Once you’ve done this, and opened the relevant notebook, you’ll see this screen (I’ve overlaid squares and numbers to refer to different parts). R-Studio is divided into four different sections, or panes. Each of these also has multiple tabs. Starting from the top-left (numbered 1): The source editor. Here is where you can edit R files such as RMarkdown or scripts. The environment pane will display any objects you create or import here, along with basic information on their type and size. This pane has a number of tabs. The default is files, which will show all the files in the current folder. You can use this to import or export additional files to R-Studio from your local machine. The console allows you to type and execute R commands directly: do this by typing here and pressing return. All four of these panes are important and worth it’s worth exploring more of the buttons and menu items. Throughout this course, you’ll complete exercises by using the source editor to edit notebooks. As you execute code in these notebooks, you’ll see objects pop into the environment pane. The console can be useful to test code that you don’t want to keep in a document. Lastly, getting to know how to use and navigate the directory structure using the files pane is essential. Using R ‘Base’ R. Commands using R without needing any additional packages are often called ‘base’ R. Here are some important ones to know: You can assign a value to an object using = or -&gt;: x = 1 y &lt;- 4 You can do basic calculations with +, -, * and /: x = 1+1 y = 4 - 2 z = x * y z ## [1] 4 You can compare numbers or variables using == (equals), &gt; (greater than), &lt;, (less than) != (not equal to). These return either TRUE or FALSE: 1 == 1 ## [1] TRUE x &gt; y ## [1] FALSE x != z ## [1] TRUE Basic R data types. It is worth understanding the main types of data that you’ll come across, in your environment window. First, you’ll have dataframes. These are the spreadsheet-like objects which you’ll use in most analyses. They have rows and columns. Next are variables. A variable is assigned to a name, and then used for various purposes. You’ll often hear of an item called a vector. A vector is a list of objects of the same type. A vector can be a single column in a dataframe (spreadsheet), which means they are used very often in R to manipulate data. A vector can have different types: for example, a character vector looks like this c(\"apples\", \"bananas\", \"oranges\"). A vector is created with the command c(), with each item in the vector placed between the brackets, and followed by a comma. If your vector is a vector of words, the words need to be in inverted commas or quotation marks. fruit = c(&quot;apples&quot;, &quot;bananas&quot;, &quot;oranges&quot;, &quot;apples&quot;) colour = c(&quot;green&quot;, &quot;yellow&quot;, &quot;orange&quot;, &quot;red&quot;) amount = c(2,5,10,8) You can create a dataframe using the data.frame() command. You just need to pass the function each of your vectors, which will become your columns. fruit_data = data.frame(fruit, colour, amount, stringsAsFactors = FALSE) Notice above that the third column, the amount, has under it instead of . That’s because R is treating it as a number, rather than a character. This means you can add them up and do all sorts of other mathy type things to them. All the items in a vector are coerced to the same type. So if you try to make a vector with a combination of numbers and strings, the numbers will be converted to strings. I wouldn’t worried too much about that for now. So for example if you create this vector, the numbers will get converted into strings. fruit = c(&quot;apples&quot;, 5, &quot;oranges&quot;, 3) fruit ## [1] &quot;apples&quot; &quot;5&quot; &quot;oranges&quot; &quot;3&quot; Tidyverse Most of the work in these notebooks is done using a set of packages developed for R called the ‘tidyverse’. These enhance and improve a large range of R functions, with much nice syntax - and they’re faster too. It’s really a bunch of individual packages for sorting, filtering and plotting data frames. They can be divided into a number of diferent categories. All these functions work in the same way. The first argument is the thing you want to operate on. This is nearly always a data frame. After come other arguments, which are often specific columns, or certain variables you want to do something with. library(tidyverse) Here are a couple of the most important ones select(), pull() select() allows you to select columns. You can use names or numbers to pick the columns, and you can use a - sign to select everything but a given column. Using the fruit data frame we created above: We can select just the fruit and colour columns: select(fruit_data, fruit, colour) ## fruit colour ## 1 apples green ## 2 bananas yellow ## 3 oranges orange ## 4 apples red Select everything but the colour column: select(fruit_data, -colour) ## fruit amount ## 1 apples 2 ## 2 bananas 5 ## 3 oranges 10 ## 4 apples 8 Select the first two columns: select(fruit_data, 1:2) ## fruit colour ## 1 apples green ## 2 bananas yellow ## 3 oranges orange ## 4 apples red group_by(), tally(), summarise() The next group of functions group things together and count them. Sounds boring but you would be amazed by how much of data science just seems to be doing those two things in various combinations. group_by() puts rows with the same value in a column of your dataframe into a group. Once they’re in a group, you can count them or summarise them by another variable. First you need to create a new dataframe with the grouped fruit. grouped_fruit = group_by(fruit_data, fruit) Next we use tally(). This counts all the instances of each fruit group. tally(grouped_fruit) ## # A tibble: 3 × 2 ## fruit n ## &lt;chr&gt; &lt;int&gt; ## 1 apples 2 ## 2 bananas 1 ## 3 oranges 1 See? Now the apples are grouped together rather than being two separate rows, and there’s a new column called n, which contains the result of the count. If we specify that we want to count by something else, we can add that in as a ‘weight’, by adding wt = as an argument in the function. tally(grouped_fruit, wt = amount) ## # A tibble: 3 × 2 ## fruit n ## &lt;chr&gt; &lt;dbl&gt; ## 1 apples 10 ## 2 bananas 5 ## 3 oranges 10 That counts the amounts of each fruit, ignoring the colour. filter() Another quite obviously useful function. This filters the dataframe based on a condition which you set within the function. The first argument is the data to be filtered. The second is a condition (or multiple condition). The function will return every row where that condition is true. Just red fruit: filter(fruit_data, colour == &#39;red&#39;) ## fruit colour amount ## 1 apples red 8 Just fruit with at least 5 pieces: filter(fruit_data, amount &gt;=5) ## fruit colour amount ## 1 bananas yellow 5 ## 2 oranges orange 10 ## 3 apples red 8 sort(), arrange() Another useful set of functions, often you want to sort things. The function arrange() does this very nicely. You specify the data frame, and the variable you would like to sort by. arrange(fruit_data, amount) ## fruit colour amount ## 1 apples green 2 ## 2 bananas yellow 5 ## 3 apples red 8 ## 4 oranges orange 10 Sorting is ascending by default, but you can specify descending using desc(): arrange(fruit_data, desc(amount)) ## fruit colour amount ## 1 oranges orange 10 ## 2 apples red 8 ## 3 bananas yellow 5 ## 4 apples green 2 If you `sortarrange() by a list of characters, you’ll get alphabetical order: arrange(fruit_data, fruit) ## fruit colour amount ## 1 apples green 2 ## 2 apples red 8 ## 3 bananas yellow 5 ## 4 oranges orange 10 You can sort by multiple things: arrange(fruit_data, fruit, desc(amount)) ## fruit colour amount ## 1 apples red 8 ## 2 apples green 2 ## 3 bananas yellow 5 ## 4 oranges orange 10 Notice that now red apples are first. left_join(), inner_join(), anti_join() Another set of commands we’ll use quite often in this course are the join() ‘family’. Joins are a very powerful but simple way of selecting certain subsets of data, and adding information from multiple tables together. Let’s make a second table of information giving the delivery day for each fruit type: fruit_type = c(&#39;apples&#39;, &#39;bananas&#39;,&#39;oranges&#39;) weekday = c(&#39;Monday&#39;, &#39;Wednesday&#39;, &#39;Friday&#39;) fruit_days = data.frame(fruit_type, weekday, stringsAsFactors = FALSE) fruit_days ## fruit_type weekday ## 1 apples Monday ## 2 bananas Wednesday ## 3 oranges Friday This can be ‘joined’ to the fruit information, to add the new data on the delivery day, without having to edit the original table (or repeat the information for apples twice). This is done using left_join. Joins need a common key, a column which allows the join to match the data tables up. It’s important that these are unique (a person’s name makes a bad key by itself, for example, because it’s likely more than one person will share the same name). Usually, we use codes as the join keys. If the columns containing the join keys have different names (as ours do), specify them using the syntax below: joined_fruit = fruit_data %&gt;% left_join(fruit_days, by = c(&quot;fruit&quot; = &quot;fruit_type&quot;)) joined_fruit ## fruit colour amount weekday ## 1 apples green 2 Monday ## 2 bananas yellow 5 Wednesday ## 3 oranges orange 10 Friday ## 4 apples red 8 Monday In this new dataframe, the correct weekday is now listed beside the relevant fruit type. Piping Another useful feature of the tidyverse is that you can ‘pipe’ commands through a bunch of functions, making it easier to follow the logical order of the code. This means that you can do one operation, and pass the result to another operation. The previous dataframe is passed as the first argument of the next function by using the pipe %&gt;% command. It works like this: fruit_data %&gt;% filter(colour != &#39;yellow&#39;) %&gt;% # remove any yellow colour fruit group_by(fruit) %&gt;% # group the fruit by type tally(amount) %&gt;% # count each group arrange(desc(n)) # arrange in descending order of the count ## # A tibble: 2 × 2 ## fruit n ## &lt;chr&gt; &lt;dbl&gt; ## 1 apples 10 ## 2 oranges 10 That code block, written in prose: “take fruit data, remove any yellow colour fruit, count the fruits by type and amount, and arrange in descending order of the total” Plotting using ggplot() The tidyverse includes a plotting library called ggplot2. To use it, first use the function ggplot() and specify the dataset you wish to graph using data =. Next, add what is known as a ‘geom’: a function which tells the package to represent the data using a particular geometric form (such as a bar, or a line). These functions begin with the standard form geom_. Within this geom, you’ll add ‘aesthetics’, which specify to the package which part of the data needs to be mapped to which particular element of the geom. The most common ones include x and y for the x and y axes, color or fill to map colors in your plot to particular data. ggplot is an advanced package with many options and extensions, which cannot be covered here. Some examples using the fruit data: Bar chart of different types of fruit (one each of bananas and oranges, two types of apple) ggplot(data = fruit_data) + geom_col(aes(x = fruit, y = amount)) Counting the total amount of fruit: ggplot(fruit_data) + geom_col(aes(x = fruit, y = amount)) Charting amounts and fruit colours: ggplot(data = fruit_data) + geom_bar(aes(x = fruit, weight = amount, fill = colour)) Reading in external data Most of the time, you’ll be working with external data sources. These most commonly come in the form of comma separated values (.csv) or tab separated values (.tsv). The tidyverse commands to read these are read_csv() and read_tsv. You can also use read_delim(), and specify the type of delimited using delim = ',' or delim = '/t. The path to the file is given as a string to the argument file=. df = read_csv(file = &#39;sample_network.csv&#39;) # Read a .csv file as a network ## Rows: 7 Columns: 3 ## ── Column specification ──────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## chr (2): from, to ## dbl (1): weight ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. df ## # A tibble: 7 × 3 ## from to weight ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 A B 5 ## 2 A C 2 ## 3 B C 4 ## 4 A D 1 ## 5 A E 8 ## 6 E D 2 ## 7 C D 3 Notice that each column has a data type beside it, either for text or for numbers. This is important if you want to sort or run calculations on the data. This has been a very quick introduction to R. There are lots of places to learn more, including: R-studio cheat sheets The Pirate’s Guide to R, a good beginners guide to base R R for data science, which teaches the tidyverse in detail Learn how to make a book like this using Bookdown EXERCISES - R Basics and Tidyverse Change the third item in the fruit vector to bananas and the corresponding item in the colour vector to yellow: fruit = c(&quot;apples&quot;, &quot;bananas&quot;, &quot;oranges&quot;, &quot;apples&quot;) colour = c(&quot;green&quot;, &quot;yellow&quot;, &quot;orange&quot;, &quot;red&quot;) amount = c(2,5,10,8) Turn this into a dataframe: Get a total for the amount of each fruit: Read in the book_sample.csv dataset, giving it the name df. It’s a random sample of 1500 books published in London, Edinburgh, and Dublin. You’ll need to find this file in the ‘data’ folder of the CSC notebooks workspace. Fill in the necessary part of the function below: Filter to only include books with Dublin as the place of publication. Call this new dataset dublin_books: Count the number of books per year in the dublin_books dataset: Count the number of books for each place of publication in the original df dataset. Save this as an object called df_count. Arrange the places in descending order of number of books: Make a bar chart of the count of places: Join the df_count dataset to the df dataset, so that each record now has the total count alongside it. "],["week-2-class-1-acquiring-and-working-with-network-data.html", "Week 2, Class 1: Acquiring and Working With Network Data", " Week 2, Class 1: Acquiring and Working With Network Data This is an R Markdown Notebook. When you execute code within the notebook, the results appear beneath the code. Try executing this chunk by clicking the Run button within the chunk or by placing your cursor inside it and pressing Cmd+Shift+Enter. plot(cars) Add a new chunk by clicking the Insert Chunk button on the toolbar or by pressing Cmd+Option+I. When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the Preview button or press Cmd+Shift+K to preview the HTML file). The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike Knit, Preview does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed. "],["week-2-class-2-data-cleaning.html", "Week 2, Class 2: Data Cleaning", " Week 2, Class 2: Data Cleaning This is an R Markdown Notebook. When you execute code within the notebook, the results appear beneath the code. Try executing this chunk by clicking the Run button within the chunk or by placing your cursor inside it and pressing Cmd+Shift+Enter. plot(cars) Add a new chunk by clicking the Insert Chunk button on the toolbar or by pressing Cmd+Option+I. When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the Preview button or press Cmd+Shift+K to preview the HTML file). The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike Knit, Preview does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed. "],["week-3-class-1-data-modelling.html", "Week 3, Class 1: Data modelling", " Week 3, Class 1: Data modelling This is an R Markdown Notebook. When you execute code within the notebook, the results appear beneath the code. Try executing this chunk by clicking the Run button within the chunk or by placing your cursor inside it and pressing Cmd+Shift+Enter. plot(cars) Add a new chunk by clicking the Insert Chunk button on the toolbar or by pressing Cmd+Option+I. When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the Preview button or press Cmd+Shift+K to preview the HTML file). The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike Knit, Preview does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed. "],["week-3-class-2-build-a-data-model-with-r.html", "Week 3, Class 2: Build a Data Model with R", " Week 3, Class 2: Build a Data Model with R This is an R Markdown Notebook. When you execute code within the notebook, the results appear beneath the code. Try executing this chunk by clicking the Run button within the chunk or by placing your cursor inside it and pressing Cmd+Shift+Enter. plot(cars) Add a new chunk by clicking the Insert Chunk button on the toolbar or by pressing Cmd+Option+I. When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the Preview button or press Cmd+Shift+K to preview the HTML file). The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike Knit, Preview does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed. "],["week-4-class-1-network-metrics.html", "Week 4, Class 1: Network Metrics Exercises Introduction Node-level metrics Edge-level metrics Global Metrics", " Week 4, Class 1: Network Metrics Exercises Note: the final section (EXERCISES - R Basics and Tidyverse) of this chapter has a number of exercises. These are stored as a separate notebook in the CSC notebook workspace, with the name 4-1-fundamentals_nb.Rmd. You’ll need to move a copy to your ‘my-work’ folder in your CSC notebook Workspace, complete the exercises, and knit them, using the method we learned in the first class. Once this is done, send a copy of the HTML file to the course leaders. Introduction Node-level metrics Degree The degree of a node is a count of its connections. Degree can be weighted and directed. In a directed network, the separate degree counts are called in-degree and out-degree. The total degree is the sum of the two. In this graph, the ego is connected to each alter by an incoming and outgoing link. Weights can be added to the links: degree is a sum of the weights of the links, in that case. The edge weights are labelled in the diagram below, and the numbers inside each node give the in and out degree measurements. Betweenness Centrality Betweenness centrality measures all the paths between every pair of nodes in a network. A node has a high betweenness centrality if it is used as a ‘hop’ between many of these paths. In the below diagram, A has a higher betweenness centrality than B, because it is needed to traverse from the left to the right side of the network. Nodes with high betweenness are often thought of as important ‘brokers’, as we talked about in a previous lesson. However in practice, note that high degree nodes are often the ones which have the highest betweenness values too, which can limit the use of this metric. Eigenvector Centrality A node that has a high eigenvector score is one that is adjacent to nodes that are themselves high scorers. Google’s original PageRank algorithm used a version of this concept: ranking web pages higher in search results if they themselves were linked to by other high-scoring pages. In the example network above, both A and B have two incoming connections each, but A has a higher eigenvector centrality score because it is connected to more well-connected nodes. Closeness centrality Closeness centrality measures each node’s path to every other node in the network: a node is declared more central if its paths to other nodes tend to be short by this measurement (the formula is 1 divided by the average of all the shortest paths from a given node to all other nodes). Closeness centrality might be thought of as a way of measuring how quickly something flowing through the network will arrive. In the diagram below, A has a higher closeness centrality than B, even though both have the same number of connections, because A is ‘less far’ to all other nodes, on average. Edge-level metrics Global Metrics Density The density of a network is defined as the fraction of edges which are present out of the total possible number of connections. Consider the undirected network below (a), which has four edges in total. The ‘full graph’ (when every node is connected to every other) of an undirected network with four nodes has six edges (b). The density of (a) therefore is 4/6, or .6666… In practice, most real-world networks are much less dense. What implication does this have on the ‘small world’ networks we talked about in an earlier class? The ‘small world’ effect works in low-density networks precisely because of the existence of hubs and weak ties. If there are very few ties in a network altogether, but there are a number of very well-connected hubs, then most nodes will be able to reach any other node by going through these hubs. In a directed network, the possible number of nodes in the full graph is doubled. Average path length The average path length is the average distance in ‘hops’ from one node to another in the network. Modularity Modularity is a score evaluating how well a given set of group labels describe the groups found in a network. It's calculated as the number of edges falling within groups minus the expected number in an equivalent network with edges placed at random (link). In the below diagram, the modularity is high, because the groups (coloured as either red or green nodes) correctly describe the two separate ‘communities’ found in the network. Community detection algorithms work by trying to maximise this value. "],["week-4-class-2-network-analysis-with-r.html", "Week 4, Class 2: Network Analysis with R” Introduction Constructing a Network in R Exercises:", " Week 4, Class 2: Network Analysis with R” Introduction A good place to start to learn R is the free book https://r4ds.had.co.nz/index.html, and if you want to learn how to use R for text mining specifically, https://www.tidytextmining.com/ is an excellent (also free) online book. This document you’re reading is called an R Notebook: it’s a special document which contains text and code. Anything within the gray block below is called a ‘chunk’. On the right-hand side you’ll see a little green triangle. Clicking that will run all the code in the chunk. 1 + 1 is very simple computer code which adds those two numbers together. Try clicking on the code. 1+1 ## [1] 2 R runs the code, and displays the output underneath the chunk. This MyBinder R environment has loaded an individual ‘container’ for you to try out the code. Feel free to edit or add new code: no changes will be saved once we finish the session. Constructing a Network in R One of the easiest data formats to construct a network is an edge list: a simple dataframe with two columns, representing the connections between two nodes, one per row. It makes particular sense with correspondence data, which is often stored as a table of letters with a ‘from’ and a ‘to’—more or less a ready-made edge list. In a correspondence dataset you might also have multiple sets of each of the edges (multiple letters between the same pair of individuals). You can add this to the edge list as an attribute called weight, which is simply another column. I use three R network libraries to do almost everything network-related, from analysis to visualisation: igraph, tidygraph and ggraph. My goal is to port everything to a format which is really easy to work with using existing my data analysis workflow. That format is known as ‘tidy data’, and it is a way of working with data which is easily transferable across a range of uses. It also means you need to learn very little new programming to do network analysis if you stay within this ‘ecosystem’. Import Network Data with the Tidyverse The whole workflow uses four packages. The first is tidyverse, a collection of various packages used for data wrangling and analytics. library(dplyr) library(magrittr) library(readr) library(stringr) Next I need some network data. On the project this is generally a comma separated values file containing the information for one letter per row. We turn the raw letter data into an edge list in a standardised format, with the from/to information, a letter date, a place, and a unique identifier for the letter. Because the dataset is large and the same names are often used repeatedly, we use a unique ID number rather than people or place names when constructing the edge list. The nice thing about working within the tidyverse is that it’s easy to then match the IDs back to actual names afterwards. These edge lists can be turned into a network object using tidygraph and the function as_tbl_graph. This function takes the first two columns in a dataset and turns them into the network graph, using any additional columns as attributes. We use two separate tables of data. First, an edge list, using unique, unambiguous numeric IDs for people and place names. Next, additional lookup tables, just with the unique ID, the person’s name, and additional information, if you have it (which can be used to filter the network afterwards). First load the two tables into R (I’ve created small sample tables to work with), which are available here and here: letters = read_csv(&quot;https://raw.githubusercontent.com/yann-ryan/dh_intro_gates/main/sample_letter_data_network.csv&quot;, col_types = cols(.default = &quot;c&quot;)) If you have multiple letters between individuals, you can sum them and use as a weight in the network, or you can ignore it. You can do this with tidyverse commands: group_by() and tally(), changing the name of the new column to ‘weight’. edge_list = letters %&gt;% group_by(author, recipient) %&gt;% tally(name = &#39;weight&#39;) Turn the edge list into a tbl_graph Next transform the edge list into a network object called a tbl_graph, using tidygraph. A tbl_graph is a graph object which can be manipulated using tidyverse grammar. This means you can create a network and then use a range of standard data analysis functions on it as needed, without learning a whole new set of commands. First, load the tidygraph library. Use as_tbl_graph() to turn the edge list into a network. The first two columns will be taken as the from and to data, and any additional columns added as attributes. It’ll automatically create a nodes table, too. library(tidygraph) sample_tbl_graph = edge_list %&gt;% as_tbl_graph() sample_tbl_graph ## # A tbl_graph: 417 nodes and 479 edges ## # ## # A directed acyclic simple graph with 1 component ## # ## # Node Data: 417 × 1 (active) ## name ## &lt;chr&gt; ## 1 Agnes Austin ## 2 Alice Thurrgood ## 3 Amye Champernowne ## 4 Ane Carnsew ## 5 Arthur Remys ## 6 Arthur Strode ## # … with 411 more rows ## # ## # Edge Data: 479 × 3 ## from to weight ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1 124 1 ## 2 2 117 1 ## 3 3 100 1 ## # … with 476 more rows The tbl_graph is an object with two tables, one for the edges and one for the nodes. You can access each of the tables using the function activate(nodes) or activate(edges). The active table has (active) after it. sample_tbl_graph = sample_tbl_graph %&gt;% activate(edges) sample_tbl_graph ## # A tbl_graph: 417 nodes and 479 edges ## # ## # A directed acyclic simple graph with 1 component ## # ## # Edge Data: 479 × 3 (active) ## from to weight ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1 124 1 ## 2 2 117 1 ## 3 3 100 1 ## 4 4 81 1 ## 5 5 125 1 ## 6 5 113 1 ## # … with 473 more rows ## # ## # Node Data: 417 × 1 ## name ## &lt;chr&gt; ## 1 Agnes Austin ## 2 Alice Thurrgood ## 3 Amye Champernowne ## # … with 414 more rows Tidygraph allows you to perform calculations on the tbl_graph using mutate, using standard igraph algorithms. So for example to calculate the degree of every node: sample_tbl_graph %&gt;% activate(nodes) %&gt;% mutate(degree = centrality_degree(mode = &#39;total&#39;)) ## # A tbl_graph: 417 nodes and 479 edges ## # ## # A directed acyclic simple graph with 1 component ## # ## # Node Data: 417 × 2 (active) ## name degree ## &lt;chr&gt; &lt;dbl&gt; ## 1 Agnes Austin 2 ## 2 Alice Thurrgood 1 ## 3 Amye Champernowne 1 ## 4 Ane Carnsew 1 ## 5 Arthur Remys 3 ## 6 Arthur Strode 2 ## # … with 411 more rows ## # ## # Edge Data: 479 × 3 ## from to weight ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1 124 1 ## 2 2 117 1 ## 3 3 100 1 ## # … with 476 more rows If you run standard functions meant to be used on a dataframe, they will happen to the active table. So if you wanted to filter just edges from ID 1, for example, you could use the filter verb from dplyr: sample_tbl_graph %&gt;% filter(from ==1) ## # A tbl_graph: 417 nodes and 1 edges ## # ## # A rooted forest with 416 trees ## # ## # Edge Data: 1 × 3 (active) ## from to weight ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1 124 1 ## # ## # Node Data: 417 × 1 ## name ## &lt;chr&gt; ## 1 Agnes Austin ## 2 Alice Thurrgood ## 3 Amye Champernowne ## # … with 414 more rows Maybe you only want to keep nodes with the title ‘Sir’? Activate the nodes again with activate(nodes), join the people table, then use filter and str_detect to filter based on a regular expressions pattern. You’ll see that it has filtered out unused edges now, too: sample_tbl_graph %&gt;% activate(nodes)%&gt;% filter(str_detect(name, &quot;(?i)sir&quot;)) ## # A tbl_graph: 14 nodes and 4 edges ## # ## # A rooted forest with 10 trees ## # ## # Node Data: 14 × 1 (active) ## name ## &lt;chr&gt; ## 1 Sir Faithful Fortescue ## 2 Sir Phelim O&amp;#x0027;Neill ## 3 Sir Richard ## 4 Sir Richard Carnsew ## 5 Sir Lucas Dillon ## 6 Sir Luke Fitzgerald ## # … with 8 more rows ## # ## # Edge Data: 4 × 3 ## from to weight ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1 10 1 ## 2 1 11 1 ## 3 3 9 1 ## # … with 1 more row Slightly more useful might be to filter based on some calculation you’ve made previously. The data format allows you to use dplyr pipes (%&gt;%) to perform one calculation on the data, then pass that new dataframe along to the next function. It works really well with tidygraph. Here we calculate the degree scores first, then filter to include only nodes with a degree score over two: sample_tbl_graph %&gt;% activate(nodes) %&gt;% mutate(degree = centrality_degree(mode = &#39;total&#39;)) %&gt;% filter(degree &gt;2) ## # A tbl_graph: 48 nodes and 76 edges ## # ## # A directed acyclic simple graph with 5 components ## # ## # Node Data: 48 × 2 (active) ## name degree ## &lt;chr&gt; &lt;dbl&gt; ## 1 Arthur Remys 3 ## 2 Capt. Nicholas Burton 3 ## 3 Captain Brandon Cusacke 4 ## 4 Christopher Creed 3 ## 5 Commissioners of the Supreme Council of the Confederate Catholics 10 ## 6 Committee for Public Revenue 3 ## # … with 42 more rows ## # ## # Edge Data: 76 × 3 ## from to weight ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1 36 1 ## 2 1 37 1 ## 3 2 33 1 ## # … with 73 more rows Exercises: Load in the network you created the previous week. Create a code chunk below to find the node with the highest degree in your network "],["week-5-class-1-visualising-networks-with-ggraph.html", "Week 5, Class 1: Visualising Networks with ggraph Visualising further information (using extra information with joins)", " Week 5, Class 1: Visualising Networks with ggraph Visualisation with ggraph The last step in the workflow is visualising the network. You can use igraph and standard R plotting libraries for this, but I use a package called ggraph, which uses the same language as ggplot (a very well-known visualisation library for R) and adds some special functions to visualise networks. To create a network diagram, first use the function ggraph on your tbl_graph, then add the special ggraph geoms geom_node_point() and geom_edge_link() library(tidygraph) library(tidyverse) library(ggraph) letters = read_csv(&quot;https://raw.githubusercontent.com/yann-ryan/dh_intro_gates/main/sample_letter_data_network.csv&quot;, col_types = cols(.default = &quot;c&quot;)) edge_list = letters %&gt;% group_by(author, recipient) %&gt;% tally(name = &#39;weight&#39;) sample_tbl_graph = edge_list %&gt;% as_tbl_graph() sample_tbl_graph ## # A tbl_graph: 417 nodes and 479 edges ## # ## # A directed acyclic simple graph with 1 component ## # ## # Node Data: 417 × 1 (active) ## name ## &lt;chr&gt; ## 1 Agnes Austin ## 2 Alice Thurrgood ## 3 Amye Champernowne ## 4 Ane Carnsew ## 5 Arthur Remys ## 6 Arthur Strode ## # … with 411 more rows ## # ## # Edge Data: 479 × 3 ## from to weight ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1 124 1 ## 2 2 117 1 ## 3 3 100 1 ## # … with 476 more rows sample_tbl_graph %&gt;% ggraph(&#39;nicely&#39;) + geom_node_point() + geom_edge_link() You can use the dplyr pipes to perform calculations, filter the data and then visualise it, all in one go: sample_tbl_graph %&gt;% activate(nodes)%&gt;% mutate(degree = centrality_degree(mode = &#39;total&#39;)) %&gt;% filter(degree &gt;2) %&gt;% ggraph(&#39;nicely&#39;) + geom_node_point() + geom_edge_link() geom_node_point() and geom_edge_link take aesthetics, just like regular ggplot geoms. You can calculate degree scores and then set the size of the nodes to the result: sample_tbl_graph %&gt;% activate(nodes)%&gt;% mutate(degree = centrality_degree(mode = &#39;total&#39;)) %&gt;% ggraph(&#39;nicely&#39;) + geom_node_point(aes(size = degree)) + geom_edge_link() Add geom_node_text() to add text labels to your network. In a larger network, it can be helpful to only show labels belonging to the most-connected nodes. First, join the people table to the nodes table, then use ggraph, setting the label aesthetic. Another dplyr verb, if_else allows you to add conditions to the label command. Here, I’ve used if_else to return the label if the node’s degree score is more than 10: sample_tbl_graph %&gt;% activate(nodes)%&gt;% mutate(degree = centrality_degree(mode = &#39;total&#39;)) %&gt;% ggraph(&#39;nicely&#39;) + geom_node_point(aes(size = degree)) + geom_node_text(aes(label = if_else(degree &gt;10, name, NULL), size = degree), repel = TRUE) + geom_edge_link(alpha = .2) ## Warning: Removed 406 rows containing missing values (geom_text_repel). Visualising further information (using extra information with joins) "],["week-5-class-2-visualising-with-gephi.html", "Week 5, class 2: Visualising with Gephi", " Week 5, class 2: Visualising with Gephi This is an R Markdown Notebook. When you execute code within the notebook, the results appear beneath the code. Try executing this chunk by clicking the Run button within the chunk or by placing your cursor inside it and pressing Cmd+Shift+Enter. plot(cars) Add a new chunk by clicking the Insert Chunk button on the toolbar or by pressing Cmd+Option+I. When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the Preview button or press Cmd+Shift+K to preview the HTML file). The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike Knit, Preview does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed. "],["week-6-class-1-bipartite-networks.html", "Week 6, Class 1: Bipartite Networks", " Week 6, Class 1: Bipartite Networks This is an R Markdown Notebook. When you execute code within the notebook, the results appear beneath the code. Try executing this chunk by clicking the Run button within the chunk or by placing your cursor inside it and pressing Cmd+Shift+Enter. plot(cars) Add a new chunk by clicking the Insert Chunk button on the toolbar or by pressing Cmd+Option+I. When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the Preview button or press Cmd+Shift+K to preview the HTML file). The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike Knit, Preview does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed. "],["week-6-class-2-literary-and-linguistic-networks.html", "Week 6, Class 2: Literary and Linguistic Networks", " Week 6, Class 2: Literary and Linguistic Networks This is an R Markdown Notebook. When you execute code within the notebook, the results appear beneath the code. Try executing this chunk by clicking the Run button within the chunk or by placing your cursor inside it and pressing Cmd+Shift+Enter. plot(cars) Add a new chunk by clicking the Insert Chunk button on the toolbar or by pressing Cmd+Option+I. When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the Preview button or press Cmd+Shift+K to preview the HTML file). The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike Knit, Preview does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed. "],["week-7-reflections.html", "Week 7: Reflections", " Week 7: Reflections This is an R Markdown Notebook. When you execute code within the notebook, the results appear beneath the code. Try executing this chunk by clicking the Run button within the chunk or by placing your cursor inside it and pressing Cmd+Shift+Enter. plot(cars) Add a new chunk by clicking the Insert Chunk button on the toolbar or by pressing Cmd+Option+I. When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the Preview button or press Cmd+Shift+K to preview the HTML file). The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike Knit, Preview does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
