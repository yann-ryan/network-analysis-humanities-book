# Week 5, Class 1: Visualising Networks with ggraph

## Network visualisations

Many analyses of networks rely on visualisation. Graphing a network is particularly useful for *descriptive data analysis*, as a way of describing the overall structure of graph, and *exploratory data analysis,* where it's used as a sort of map to understand its various components, and to help spot patterns or interesting features by eye. These visualisations are most often the points and lines type diagrams which we have used throughout this book, but there are also a number of other ways they can be visualised (which often might be more useful).

It's important to note that there is nothing inherently spatial about a graph: it is simply a record of connections between nodes. When we choose to represent it visually, we have to make decisions as to its form and how precisely its nodes and edges are placed in 2D (or even 3D) space.

From early social network research, researchers tried to manually visualise these graphs in meaningful ways, for example by placing closely-connected clusters together (and away from other clusters), placing important or highly-connected nodes towards the centre, or minimising the number of edge (line) crossings. With large networks, today this process is usually carried out using algorithms to work out the node placements.

### Force-directed network visualisations

The most common family of these algorithms are 'force-directed', meaning they use a simulation of physical forces in order to create sensible placements of nodes. One of the most common of these is the Fruchterman-Reingold layout, which treats edges like a spring. Nodes which share an edge are attracted to each other using a spring-like force; every pair of nodes in the system also has a repulsive force. The algorithm simulates this physical system and stops when the distances between the nodes means that the system is in equilibrium.

A good force-directed graph can actually convey a great deal of information about a network. The paper for this week's reading argues that the ambiguity of a force-directed graph can actually make them very useful for exploratory data analysis, when they are interpreted correctly.

#### Reading a network graph

Using a similar approach to that paper, consider this network of book publishers from the eighteenth century:

![](images/full_net.png)

This is a large network, consisting of tens of thousands of nodes and millions of edges. The nodes are coloured by 'community', meaning tthat each colour of nodes is more densely connected to each other than to the nodes of other colours. Despite its size, some structure can be seen. We could describe it as the following:

-   Spatially (ignoring the colours), there are three main sections: a large central section, and two smaller sections, one to the bottom-right and another, even smaller, to the top-left of the main section.

-   This main section is shaped a bit like a hairbrush: it has an elongated 'handle', and an attached 'brush' at the top.

-   The colours are distinct, meaning that the force-directed graph did a good job in replicating the clusters found by the community detection algorithm.

To understand why it might have this shape, we looked into the nodes in each of its clusters.

The first thing we noted was that the almost separate 'islands' were groups of Dublin (larger and closer island) and US publishers.

The main section is made up of clusters of different time periods. Each time period is connected to the others mainly by a short edge, meaning that (for example) the 1700 - 1720 cluster is much more connected to the 1720 - 1740 cluster than to the 1780 - 1800 cluster, for example. This is typical in a long, multi-generational dataset like this.

The handle is mostly London-based publishers, and the 'brush' is a group of Scottish publishers. These Scottish publishers are mostly connected to the later London clusters (red/pink). Scottish publishers are much closer to the London core than either Dublin or US.

Some inferences we might make from this diagram.

-   US and Dublin publishers were very separate from a London/Edinburgh publishing axis.

-   For London publishers, the strongest pull is temporal rather than any other aspect.

-   Over time, the closeness of the Edinburgh and London publisher networks grew.

When used correctly and with more knowledge about a network, force-directed diagrams like this can help to spot distinct clusters, structural 'holes', and other features of a network.

#### Avoiding the dreaded 'hairball'

Visualising large networks using these methods can often result in a large tangled mass of nodes and edges, known perojatively as a 'hairball'. This is particularly true of large graphs without much of a tendency to cluster together, such as this graph of Facebook page networks[@musae].

```{r echo=FALSE, message=FALSE, warning=FALSE, cache = TRUE}

g = data.table::fread('/Users/yannryan/Downloads/tvshow_edges.csv') %>% 
  mutate(node_1 = node_1 + 1) %>% mutate(node_2 = node_2+1)

g %>% 
  graph_from_data_frame() %>% 
  ggraph('fr', niter = 1000) +
  geom_edge_link(alpha = .1) + 
  geom_node_point(alpha = .5)

```

These graphs have limited use, even as exploratory data. There are some ways to mitigate against them, however:

-   Consider filtering the network, as in the previous steps. Make sure you're aware of the consequences of filtering before and after you calculate network metrics, however.

-   For large graphs, software such as Gephi, because it gives a real-time feedback of a network visualisation, can be useful, rather than purely using a programming language such as R.

-   Think about whether a network diagram (or a network model at all) is the best way to represent or display your data. Could you arrive at the same conclusions with a simpler data analysis and output, such as a bar chart?

### Other Network Visualisations

There are many other ways besides a 'force-directed' graph to visualise a network.

#### Bipartite graph

Some network types are particularly suited to other visualisation methods. Bipartite networks, for example, are often visualised so that the nodes are placed in two rows, according to their types. The positions within the rows are then determined by an algorithm designed to minimise edge crossings.

```{r message=FALSE, warning=FALSE}
EL = c(1,7,2,6,3,8,2,5,4,6,1,5,2,6)
types = rep(0:1, each=4)
g = make_bipartite_graph(types, EL, directed = FALSE)

g %>% ggraph('bipartite')+ 
  geom_edge_link() + 
  geom_node_point(size = 10, aes(color = as.character(types)))  + coord_flip() + theme_void() + theme(legend.position = 'bottom') + labs(color = 'Type:')
```

#### Adjacency Matrix

One popular alternative to a network diagram is an *adjacency matrix.* In this case, the x and y axes contain each name in the network. A filled square is drawn for each edge, where they intersect.

This method can be particularly useful for small, dense networks.

```{r echo=FALSE, message=FALSE, warning=FALSE}
letters = read_csv("letter_data.csv", col_types = cols(.default = "c"))
edge_list = letters %>% 
  filter(date <'1670-12-31')%>% 
  group_by(from_id, to_id) %>% 
  tally(name = 'weight') 

g = edge_list %>% 
  as_tbl_graph(directed = F) %>% 
  mutate(group = group_louvain()) 
e = g %>% activate(edges) %>% as_tibble()
n   = g %>% as_tibble() %>% mutate(id = 1:nrow(.))

ge = e %>% left_join(n, by = c('from'= 'id'))%>% 
  left_join(n, by = c('to'= 'id')) %>% 
  mutate(group = ifelse(group.x == group.y, group.x, NA))

all_nodes = n$name
name_order <- (n %>% arrange(group))$name

p_data = ge  %>% mutate(
        to = factor(name.x, levels = name_order),
        from = factor(name.y, levels = name_order))

ggplot(p_data, aes(x = from, y = to, fill = as.character(group))) +
      geom_raster() +
      theme_bw() +
      # Because we need the x and y axis to display every node,
      # not just the nodes that have connections to each other,
      # make sure that ggplot does not drop unused factor levels
      scale_x_discrete(drop = FALSE) +
      scale_y_discrete(drop = FALSE) +
      theme(
        # Rotate the x-axis lables so they are legible
        axis.text = element_blank(),
        # Force the plot into a square aspect ratio
        aspect.ratio = 1,
        # Hide the legend (optional)
        legend.position = "none")
```

## Network Visualisations with R and ggraph.

Visualisations like the examples above can be created with another R package, called `ggraph`. This uses the same basic syntax as the plotting library `ggplot2`, we used in an earlier lesson, but adds some special functions to visualise networks.

To create a network diagram,we first create a network object as in previous lessons.

```{r message=FALSE, warning=FALSE}

library(tidygraph)
library(tidyverse)
library(ggraph)
letters = read_csv("letter_data.csv", col_types = cols(.default = "c"))

edge_list = letters %>% 
  group_by(from_id, to_id) %>% 
  tally(name = 'weight')

sample_tbl_graph = edge_list %>% 
  as_tbl_graph()


```

This object is then passed to the function `ggraph()`, using the pipes.

`ggraph()` tells R to begin drawing a graph. It has optional arguments: for example, you can set the layout to something other than the default using the argument `layout =`.

```{r}
sample_tbl_graph %>% ggraph(layout = 'fr')
```

You'll notice that it doesn't draw anything other than a blank grey background.

`ggraph` uses the syntax as the plotting library `ggplot2`. Recall from Week 1, class 2, that plots in `ggplot2` are created by adding `geom_` functions to the blank plot.

The same principle applies here, except with special `ggraph` geoms:

-   First, `geom_node_point()`, will draw the nodes of your network as points. The nodes are positioned using the chosen (or default) layout algorithm.

-   Next, `geom_edge_link()` will drawn the edges as connecting lines.

```{r}
sample_tbl_graph %>% 
  ggraph('fr') + 
  geom_node_point() + 
  geom_edge_link()

```

There are many additional ways you can manipulate the visual appearance of your nodes and edges, for example by adding color, size, shape, arrows, and so forth.

In ggraph (and ggplot), visual elements can be manipulated in two ways: you can either specify a value for a visual property, or you can specify that a property is mapped to a particular data point.

This is all done with the relevant geom. To do the former, specify the value directly in the geom, like this:

```{r}
sample_tbl_graph %>% 
  ggraph('fr') + 
  geom_node_point(size = 3) + # we specified that size should be set at the value 3
  geom_edge_link()

```

To map data to a particular data point, specify the data to be used within the geom, within a command `aes()`:

```{r}
sample_tbl_graph %>% 
  mutate(degree = centrality_degree()) %>% # calculate a value for degree
  ggraph('fr') + 
  geom_edge_link() + # switch around the order of the nodes and edges as it's easier to see the node color
  geom_node_point(size = 3, aes(color = degree)) # as well as the size, color is now mapped to the degree score.
```

Other visual properties which can be mapped or specified include `shape` and `alpha`.

The visual appearance of edges can also be adjusted, using the same syntax.

Change to a dashed line using `linetype`:

```{r}
sample_tbl_graph %>% 
  mutate(degree = centrality_degree()) %>% 
  ggraph('fr') + 
  geom_edge_link(linetype = 5) + 
  geom_node_point(size = 3, aes(color = degree))
```

You can also add arrows, with the following syntax. The `length` and `endcap` arguments control the appearance of the arrow.

```{r}

sample_tbl_graph %>% 
  mutate(degree = centrality_degree()) %>% 
  ggraph('fr') + 
  geom_edge_link(linetype = 5,
                 arrow = arrow(length = unit(4, 'mm')), 
                   end_cap = circle(3, 'mm')) + 
  geom_node_point(size = 3, aes(color = degree))

```

### Ggraph and other tidyverse functions

You can use the dplyr pipes to perform calculations, filter the data and then visualise it, all in one go:

```{r}
sample_tbl_graph %>% 
  activate(nodes)%>% 
  mutate(degree = centrality_degree(mode = 'total')) %>% # calculate total degree 
  filter(degree >2) %>% # filter to only include nodes with a degree greater than 2.
  ggraph('fr') + 
  geom_node_point() + 
  geom_edge_link()
```

### Add node labels

Add `geom_node_text()` to add text labels to your network. In a larger network, it can be helpful to only show labels belonging to the most-connected nodes.

To do this, join the people table to the nodes table, then use ggraph, setting the `label` aesthetic. Another `dplyr` verb, `if_else` allows you to add conditions to the label command.

Here, I've used if_else to return the label if the node's degree score is more than 10:

A the moment, we only have the IDs for each node. In a further step we can join back the actual names and use these as labels.

```{r}

sample_tbl_graph %>% 
  activate(nodes) %>% 
  mutate(degree = centrality_degree(mode = 'total'))  %>% 
  ggraph('nicely') + 
  geom_node_point(aes(size = degree)) + 
  geom_node_text(aes(label = if_else(degree >10, name, NULL), size = degree), repel = TRUE) + 
  geom_edge_link(alpha = .2)

```

### Calculating and coloring by community detection

One very common visualisation is colouring the various groups in the network, which might give us a clue as to its structure.

```{r}
sample_tbl_graph %>% 
  as.undirected() %>% 
  as_tbl_graph() %>% 
  activate(nodes) %>% 
  mutate(degree = centrality_degree(mode = 'total'))  %>% 
  mutate(community = group_edge_betweenness(weights =NULL)) %>% 
  filter(community %in% 1:4) %>% 
  ggraph('nicely') + 
  geom_node_point(aes(size = degree, color = as.character(community))) + 
  geom_edge_link(alpha = .2)
```

## Case study: Scientists and Politicians

In this final section, I'll demonstrate how these methods might be used to carry out exploratory data analysis on the sample letter dataset.

The node attributes can used either to filter the network, or added as extra visual elements. Doing so helps us to understand a bit more about why the network might look the way it does.

First, load the same node attributes table as before:

```{r}
node_attributes = read_csv('node_attributes.csv')
```

This external information might help us to make sense of the clusters found by the community detection algorithm used above. One of the fields in the data is whether that person is listed as a politician on Wikidata: the field is a simple flag of either `yes` or `no`.

To check whether this might be a clue towards the structure of the network, we will set the *color* to the community detection results, and the *shape* to the politician flag, with the following code:

```{r message=FALSE, warning=FALSE}
sample_tbl_graph %>% 
  as.undirected() %>% 
  as_tbl_graph()%>% 
  activate(nodes) %>% 
  mutate(degree = centrality_degree(mode = 'total')) %>% 
  left_join(node_attributes) %>% 
  mutate(community = group_edge_betweenness(weights =NULL)) %>% 
  filter(community %in% 1:4) %>% 
  ggraph('fr') + 
  geom_edge_link(alpha = .2)+ 
  geom_node_point(aes(size = degree, color = as.character(community), shape = politician))  + 
  geom_node_text(aes(label = ifelse(degree >2, main_name, NA)), size = 2.5, repel = T) + 
  theme(legend.position = 'none')
```

It does look like one of the four clusters (cluster 2) has far fewer politicians. This cluster seems to be a group of what might be described as natural philosophers.

Other things to look out for in this visualisation:

-   What is the importance of the nodes sitting in between the scientists and the politicians? What metrics might they score highly on, and what role might they occupy in this system? What kinds of information may they be able to pass on?

-   What is the position of Athanasius Kircher? What does it mean to be on the periphery of this network?

-   What effect might additional data have on the metrics in this network? Should this make us cautious about any inference from this network?

## Conclusions

Hopefully, from reading this chapter, you'll be convinced that network visualisations are useful, but that they should also be approached with caution. The bottom line is, visualisations of themselves are not a result: at the very least, they need extensive commentary in order to explain them, and in some cases, they may simply be useful ways of describing the network.

At the same time, in combination with the additional attributes from our data model, thoughtful visualisations can be incredibly useful for exploring a network dataset, revealing patterns that are otherwise hidden. I encourage you to use visualisations in your final project if they make sense, are not just 'hairballs', and if they can be justified with relevant commentary.
